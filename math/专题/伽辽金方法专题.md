# 伽辽金方法

伽辽金方法是解微分方程的一种方法 ，属于加权余量法的重要常用分支

1 选取近似解， 需要满足边界条件

2 求出余量

3 选择权函数 确定权函数系数

## 举例

已知微分方程

$$
\frac{d^2u}{dx^2}-u=-x,0<x<1 
$$
且
$$
u(0)=0,u(1)=0
$$

我们已知有解析的精确解
$$
u(x)=x-\frac{e^x-e^{-x}}{e-e^{-1}}
$$

## 伽辽金操作

伽辽金选择的权函数为
$$
\omega_i=\frac{d \tilde u}{dC_i}
$$


然后多项式拟制一个一次近似解 我们可以从一次开始 需要满足边界条件 C1是待定的系数
$$
\tilde u = C_1x(1-x)
$$
权函数为
$$
x(1-x)
$$

近似解带入方程  
$$
R = \frac{d^2\tilde u}{dx^2}-u+x = 2C_1 - C_1x(1-x)+x
$$

然后构造定积分 求系数C1
$$
I=\int_0^1 \omega_1 Rdx = \int_0^1 x(1-x)  [2C_1 - C_1x(1-x)+x ]dx=0
$$

计算该定积分 解方程
$$
C_1 =\frac3{13}
\tilde u = \frac3{13}x(1-x) 
$$

于是近似解也就出来了







## Python实现

### 一次近似解

```PYTHON
import sympy as smp
import numpy as np
import matplotlib.pyplot as plt

# 伽辽金方法  
# 参数设定
u=smp.symbols('u',cls=smp.Function)
x=smp.symbols('x',real=True)
C1=smp.symbols('C1') 

# expr 构建近似多项式uH   以及近似解对系数的倒数w
uH=C1*x*(1-x)  
w=smp.diff(uH,C1)

# 近似多项式带入构建方程exprR  并得到定积分结果式子expr
exprR =w*( smp.diff(smp.diff(uH,x),x)-uH+x )
expr=smp.integrate(exprR,(x,0,1)).doit()
print(expr)

#将上述定积分结果式子趋于0 并 解方程equation的系数C1
equation=smp.Eq(expr,0) 
ttr=smp.solve(equation,C1)  
ceoff1=ttr[0] 
print(ceoff1)

# 得出近似多项式实际样貌
uH=ceoff1*x*(1-x) 
print(uH)

# 已知解析解
std = x - (smp.exp(x)-smp.exp(-x))/(smp.exp(1)-smp.exp(-1))
std

# 解析解 和 近似解 两者函数化
std_f=smp.lambdify([x],std)
uH_f=smp.lambdify([x],uH)

#显示两条曲线
x_num=np.linspace(0,1,100) 
plt.plot(x_num,std_f(x_num),color='green')
plt.plot(x_num,uH_f(x_num),color='red')
plt.show()
```



### 二次近似解

```python

import sympy as smp
import numpy as np
import matplotlib.pyplot as plt
# 伽辽金方法 2
# 参数设定 
x=smp.symbols('x',real=True)
C1=smp.symbols('C1',real=True)
C2=smp.symbols('C2',real=True)

# expr 构建近似多项式uH   以及近似解对系数的倒数w
uH=C1*x*(1-x)  + C2*x**2*(1-x) 
w1=smp.diff(uH,C1)
w2=smp.diff(uH,C2)

# 近似多项式带入构建方程exprI1  并得到定积分结果式子expr1 
exprI1=smp.integrate(w1* (smp.diff(smp.diff(uH,x),x)-uH+x),(x,0,1)) .doit() 
#式子exprI2
exprI2=smp.integrate(w2* (smp.diff(smp.diff(uH,x),x)-uH+x),(x,0,1)).doit() 

# expr1 expr2  联立解方程
coeff=smp.solve([exprI1,exprI2],[C1,C2])  
print(coeff)
# 得出近似多项式实际样貌
uH=uH.subs([(C1,coeff[C1]),(C2,coeff[C2])])
print(uH)
# 已知解析解
std = x - (smp.exp(x)-smp.exp(-x))/(smp.exp(1)-smp.exp(-1))
std

# 解析解 和 近似解 两者函数化
std_f=smp.lambdify([x],std)
uH_f=smp.lambdify([x],uH)

#显示两条曲线
x_num=np.linspace(0,1,100) 
plt.plot(x_num,std_f(x_num),color='blue')
plt.plot(x_num,uH_f(x_num),color='red')
plt.show()
```



### 把伽辽金法打包为方法

```python


import sympy as smp
import numpy as np
import matplotlib.pyplot as plt

##############
##############一元伽辽金方法
#expr=(smp.diff(smp.diff(uH,x),x)-uH+x)
#coeffs=[smp.symbols('C1',real=True),smp.symbols('C2',real=True)]
#approxExpr =uH=   C1*x*(1-x)  + C2*x**2*(1-x) 
#limit=(x,0,1)
def Galerkin(expr ,coeffs,approxExpr,limit) : 
    exprIs=[] 
    for coeff in  coeffs:
        w=smp.diff(approxExpr,coeff)
        # ws.append(smp.diff(approxExpr,coeff)) 
        exprI=smp.integrate(w* expr,limit) .doit() 
        exprIs.append(exprI)

    coeffDict=smp.solve(exprIs,coeffs)  
 
    for coeff in  coeffs:  
        approxExpr=approxExpr.subs([(coeff,coeffDict[coeff])]) 
    print(approxExpr)
    approxExprFunc=smp.lambdify([limit[0]],approxExpr)
    return( approxExpr, approxExprFunc)
##############   
##############

################## # 伽辽金方法 验证
C1=smp.symbols('C1',real=True)
C2=smp.symbols('C2',real=True)
coeffs=[C1,C2]

x=smp.symbols('x',real=True)
limit=(x,0,1)
uH=C1*x*(1-x)  + C2*x**2*(1-x) 
expr=(smp.diff(smp.diff(uH,x),x)-uH+x)

approxExpr = Galerkin(expr,coeffs,uH,limit)
uH = approxExpr[0]
print(uH) 
################## #

# 已知解析解
std = x - (smp.exp(x)-smp.exp(-x))/(smp.exp(1)-smp.exp(-1))
std

# 解析解 和 近似解 两者函数化
std_f=smp.lambdify([x],std)
uH_f=smp.lambdify([x],uH)
##########
#显示两条曲线
x_num=np.linspace(0,1,100) 
plt.plot(x_num,std_f(x_num),color='blue')
plt.plot(x_num,uH_f(x_num),color='red')
plt.show()

```

